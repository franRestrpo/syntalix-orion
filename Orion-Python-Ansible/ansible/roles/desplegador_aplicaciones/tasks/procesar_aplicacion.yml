# Lógica de procesamiento para una aplicación individual

- name: "Inicializar variable app_actual"
  ansible.builtin.set_fact:
    app_actual: "{{ app_item }}"

- name: "Verificar si existe archivo .env previo"
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/deploy/{{ app_actual.nombre }}.env"
  register: env_file_check

- name: "Cargar configuración existente del .env si existe"
  ansible.builtin.shell: |
    grep -E "^(FRONTEND_URL|N8N_HOST|DOMAIN|URL|TRAEFIK_DASHBOARD_URL|PORTAINER_DOMAIN)=" {{ playbook_dir }}/deploy/{{ app_actual.nombre }}.env | head -n 1 | cut -d= -f2 | sed 's/https:\/\///g' | sed 's/http:\/\///g' | sed 's/\///g' || echo ""
    grep -E "^(POSTGRES_PASSWORD|DB_POSTGRESDB_PASSWORD|DB_PASSWORD|TRAEFIK_PASSWORD|PASSWORD)=" {{ playbook_dir }}/deploy/{{ app_actual.nombre }}.env | head -n 1 | cut -d= -f2 || echo ""
    grep -E "^(MAILER_SENDER_EMAIL|N8N_SMTP_SENDER|ADMIN_EMAIL|ACME_EMAIL|TRAEFIK_USER)=" {{ playbook_dir }}/deploy/{{ app_actual.nombre }}.env | head -n 1 | cut -d= -f2 || echo ""
  register: existing_config
  changed_when: false
  when: env_file_check.stat.exists

- name: "Preguntar si se mantienen los valores para {{ app_actual.nombre }}"
  ansible.builtin.pause:
    prompt: "Se detectó configuración previa para {{ app_actual.nombre }}. ¿Desea mantener los valores actuales? (s/n, Enter para s):"
  register: keep_config
  when: env_file_check.stat.exists and existing_config.stdout_lines | length > 0 and existing_config.stdout_lines[0] != ""

- name: "Establecer flag de actualización"
  ansible.builtin.set_fact:
    update_needed: "{{ not env_file_check.stat.exists or (keep_config.user_input | default('s') | lower) == 'n' }}"

- name: "Establecer defaults desde .env o base"
  ansible.builtin.set_fact:
    default_dominio: "{{ (env_file_check.stat.exists and existing_config.stdout_lines | length > 0 and existing_config.stdout_lines[0] != '') | ternary(existing_config.stdout_lines[0], app_actual.nombre + '.localhost') }}"
    default_pass: "{{ (env_file_check.stat.exists and existing_config.stdout_lines | length > 1 and existing_config.stdout_lines[1] != '') | ternary(existing_config.stdout_lines[1], 'admin123') }}"
    default_admin: "{{ (env_file_check.stat.exists and existing_config.stdout_lines | length > 2 and existing_config.stdout_lines[2] != '') | ternary(existing_config.stdout_lines[2], 'admin@' + ((env_file_check.stat.exists and existing_config.stdout_lines | length > 0 and existing_config.stdout_lines[0] != '') | ternary(existing_config.stdout_lines[0], app_actual.nombre + '.localhost'))) }}"

- name: "Solicitar Dominio para {{ app_actual.nombre }}"
  ansible.builtin.pause:
    prompt: "Ingrese el dominio para {{ app_actual.nombre }} (Enter para usar {{ default_dominio }}):"
  register: input_dominio
  when: app_actual.dominio is not defined and update_needed

- name: "Establecer Dominio Final"
  ansible.builtin.set_fact:
    dominio_final: "{{ (input_dominio.user_input is defined and input_dominio.user_input | length > 0) | ternary(input_dominio.user_input, default_dominio) }}"
  when: app_actual.dominio is not defined

- name: "Establecer Dominio desde Config"
  ansible.builtin.set_fact:
    dominio_final: "{{ app_actual.dominio }}"
  when: app_actual.dominio is defined

- name: "Solicitar Email Admin para {{ app_actual.nombre }}"
  ansible.builtin.pause:
    prompt: "Ingrese el email admin para {{ app_actual.nombre }} (Enter para usar {{ default_admin }}):"
  register: input_admin
  when: app_actual.usuario_admin is not defined and update_needed

- name: "Establecer Admin Final"
  ansible.builtin.set_fact:
    admin_final: "{{ (input_admin.user_input is defined and input_admin.user_input | length > 0) | ternary(input_admin.user_input, default_admin) }}"
  when: app_actual.usuario_admin is not defined

- name: "Establecer Admin desde Config"
  ansible.builtin.set_fact:
    admin_final: "{{ app_actual.usuario_admin }}"
  when: app_actual.usuario_admin is defined

- name: "Solicitar Password DB para {{ app_actual.nombre }}"
  ansible.builtin.pause:
    prompt: "Ingrese el password de DB para {{ app_actual.nombre }} (Enter para usar {{ default_pass }}):"
    echo: no
  register: input_pass_db
  when: app_actual.password_db is not defined and update_needed

- name: "Establecer Password DB Final"
  ansible.builtin.set_fact:
    pass_db_final: "{{ (input_pass_db.user_input is defined and input_pass_db.user_input | length > 0) | ternary(input_pass_db.user_input, default_pass) }}"
  when: app_actual.password_db is not defined

- name: "Establecer Password DB desde Config"
  ansible.builtin.set_fact:
    pass_db_final: "{{ app_actual.password_db }}"
  when: app_actual.password_db is defined

- name: "Actualizar diccionario de aplicación con valores finales"
  ansible.builtin.set_fact:
    app_actual: "{{ app_actual | combine({
      'dominio': dominio_final,
      'usuario_admin': admin_final,
      'password_db': pass_db_final,
      'acme_email': admin_final
    }) }}"

- name: "Validar datos requeridos para {{ app_actual.nombre }}"
  ansible.builtin.fail:
    msg: "Falta el dominio para la aplicación {{ app_actual.nombre }}"
  when: app_actual.dominio is not defined

- name: "Informar estado de procesamiento para {{ app_actual.nombre }}"
  ansible.builtin.debug:
    msg: "Procesando configuración para {{ app_actual.nombre }}..."

# Gestión de Dependencias (Redis, Postgres, etc.)
- name: "Procesar dependencias para {{ app_actual.nombre }}"
  include_tasks: dependencias.yml
  when: app_actual.dependencias is defined

- name: "Crear directorio de despliegue si no existe"
  ansible.builtin.file:
    path: "{{ playbook_dir }}/deploy"
    state: directory
    mode: "0755"

- name: "Generar/Recuperar Clave de Encriptación para N8N"
  ansible.builtin.set_fact:
    clave_encriptacion_n8n: "{{ lookup('password', 'credenciales/' + app_actual.nombre + '_encryption_key chars=hex length=16') }}"
  when: app_actual.nombre == 'n8n'

- name: "Generar/Recuperar Secret Key para Chatwoot"
  ansible.builtin.set_fact:
    chatwoot_secret_key_base: "{{ lookup('password', 'credenciales/' + app_actual.nombre + '_secret_key chars=ascii_letters,digits length=64') }}"
  when: app_actual.nombre == 'chatwoot'

- name: "Generar/Recuperar Global API Key para Evolution"
  ansible.builtin.set_fact:
    evolution_api_key: "{{ lookup('password', 'credenciales/' + app_actual.nombre + '_api_key chars=hex length=16') }}"
  when: app_actual.nombre == 'evolution'

- name: "Generar archivo .env para {{ app_actual.nombre }}"
  ansible.builtin.template:
    src: "{{ app_actual.nombre }}.env.j2"
    dest: "{{ playbook_dir }}/deploy/{{ app_actual.nombre }}.env"
  register: config_env
  ignore_errors: true

- name: "Generar docker-compose para {{ app_actual.nombre }}"
  ansible.builtin.template:
    src: "{{ app_actual.nombre }}.yml.j2"
    dest: "{{ playbook_dir }}/deploy/{{ app_actual.nombre }}_stack.yml"
  register: config_stack

- name: "Desplegar Stack {{ app_actual.nombre }}"
  ansible.builtin.command:
    cmd: "docker stack deploy -c {{ app_actual.nombre }}_stack.yml {{ app_actual.nombre }}"
    chdir: "{{ playbook_dir }}/deploy"
  when: config_stack.changed or config_env.changed or (app_actual.nombre not in (stacks_activos.stdout_lines | default([])))

- name: "Esperar a que Postgres esté listo para {{ app_actual.nombre }}"
  ansible.builtin.shell: "docker service logs {{ app_actual.nombre }}_postgres 2>&1 | grep 'ready to accept connections' | tail -n 1"
  register: postgres_ready
  until: postgres_ready.rc == 0
  retries: 30
  delay: 5
  when: app_actual.nombre == 'chatwoot' and config_stack.changed

- name: "Inicializar base de datos via Servicio (Swarm)"
  block:
    - name: "Eliminar servicio de migración anterior si existe"
      ansible.builtin.shell: "docker service rm {{ app_actual.nombre }}_migrator || true"
      ignore_errors: true

    - name: "Crear servicio de migración para {{ app_actual.nombre }}"
      ansible.builtin.command:
        cmd: >
          docker service create 
          --name {{ app_actual.nombre }}_migrator
          --network SyntalixNet
          --restart-condition none
          --env-file {{ playbook_dir }}/deploy/{{ app_actual.nombre }}.env
          chatwoot/chatwoot:latest
          bundle exec rails db:chatwoot_prepare

    - name: "Esperar a que termine la migración"
      ansible.builtin.shell: "docker service ps {{ app_actual.nombre }}_migrator --no-trunc --format '{{ '{{' }}.CurrentState{{ '}}' }}' | head -n 1"
      register: migration_status
      until: "migration_status.stdout is search('Complete|Shutdown')"
      retries: 60
      delay: 5
      failed_when: "migration_status.stdout is search('Failed|Rejected')"

    - name: "Limpiar servicio de migración"
      ansible.builtin.command: "docker service rm {{ app_actual.nombre }}_migrator"

  when: app_actual.nombre == 'chatwoot' and (config_stack.changed or config_env.changed)
